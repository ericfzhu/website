When you have a recursive function that makes multiple calls, the runtime will often look like O(branches^depth)

## Walking Through a Problem

It’s much easier to visualise a problem using a whiteboard or a piece of paper than only in your head, so just draw it out. Any examples you use should be sufficiently large and not an optimal scenario of the problem.

Create a brute force solution first. Communicate through the solution and don’t start coding at this point. Only think about optimisation strategies after the brute force method.

## Look for BUD

* **Bottlenecks**: look for areas of the code with high complexity

* **Unnecessary** work

* **Duplicated** work

## DIY

Try working it through intuitively on a real example. Solutions that may not be immediately obvious can reveal themselves when drawn out.

## Simplify and Generalise

Try simplifying or relaxing some of the constraints of the problem, and solving the easier problem first. You can then build on top of the solution for the simple problem to adapt it for the actual problem at hand.

## Base Case and Build

Solve the problem for a base case (e.g. n = 1), and then build up from there. This can often lead to solutions using recursion.

## Data Structure Brainstorm

Try running through a list of all the data structures and apply each one. Pretty hacky solution though so don’t recommend unless no other ideas.





